#!/usr/bin/env python

from __future__ import print_function
import argparse
import subprocess
import json
import os
import requests
import subprocess
import sys

def parse_args():
    parser = argparse.ArgumentParser(description='Get an Interactive Bash session into your container.')
    parser.add_argument('appTaskId', metavar='appTaskId', help="Application Task Id to uniquely \
	 identify a container Id. example: 'content.56847afe9799")
    parser.add_argument('-environment', metavar='env', help="Environment to deploy to. \
	 example: 'dev' or 'stage'")
    parser.add_argument('-H','--hostname', metavar='hostname', help="Hostname to search.\
	  example: 'daldevmesos01' or 'daldevmesos04'")
    return parser

def get_hostname_from_marathon(root, environment, roger_env, appTaskId):
    hostname = ''
    headers = {'Accept': 'application/json','Accept-Encoding': 'gzip, deflate','Content-Type': 'application/json'}
    url = roger_env['environments'][environment]['marathon_endpoint']+'/v2/tasks?status=running'	
    resp = requests.get("{}".format(url), headers=headers)
    tasks = resp.json()['tasks']
    for task in tasks:
        if task['id'].startswith(appTaskId):
            hostname = task['host']

    return hostname

def get_containerid(appTaskId, hostname):
    containerId = ''
    try:
        containers = subprocess.check_output("docker -H tcp://{}:4243 ps -q".format(hostname), shell=True)        
    except:
        print("No route to host. Please check hostname '{}'".format(hostname), file=sys.stderr)
        return
    for container in containers.split('\n'):
        if container.strip() != '':
            mesosTaskId = subprocess.check_output("docker -H tcp://{0}:4243 exec {1} \
		printenv MESOS_TASK_ID".format(hostname,container), shell=True)
            if mesosTaskId:
                if mesosTaskId.startswith(appTaskId):
                    containerId = container.strip()
                    break
            else:
                print("Mesos Task Id info fetched is empty/blank for container id - {0}".format(container))
    return containerId

def main():
    parser = parse_args()
    args = parser.parse_args()
    with open('{0}/config/roger-env.json'.format(root)) as roger_env:
        roger_env = json.load(roger_env)
    
    environment = ''
    if 'default' in roger_env:
      environment = roger_env['default']
    
    if args.environment is None:
      if "ROGER_ENV" in os.environ:
        env_var = os.environ.get('ROGER_ENV')
        if env_var == '':
          print("Environment variable $ROGER_ENV is not set.Using the default set from roger-env.json file")
        else:
          print("Using value {} from environment variable $ROGER_ENV".format(env_var))
          environment = env_var
    else:
      environment = args.environment

    if environment not in roger_env['environments'].keys():
      sys.exit('Environment not found in roger-env.json file.')

    hostname = ''
    containerId = ''
    root = os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../'))
    if args.hostname == None:
        hostname = get_hostname_from_marathon(root, environment, args.appTaskId);
    else:
        hostname = args.hostname;

    if hostname != '':	#Hostname maybe empty when the given appTaskId does not match any taskId from Marathon
        containerId = get_containerid(args.appTaskId, hostname);
    else:
        print("Most likely hostname could not be retrieved with appTaskId {0}. Hostname is also \
an optional argument. See -h for usage.".format(args.appTaskId));
    if containerId != '' and containerId != None:
        print("If there are multiple containers that pattern match the given mesos task Id, \
then will log into the first one")
        print("Executing bash in docker container - {0} on host - {1}".format(containerId, hostname));
        subprocess.check_call("docker -H tcp://{0}:4243 exec -it {1} bash".format(hostname, containerId), shell=True); 
    else:
        print("No Container found on host {0} with application Task Id {1}".format(hostname, args.appTaskId));

if __name__ == '__main__':
    main()

#!/usr/bin/python

from __future__ import print_function
import argparse
from decimal import *
from jinja2 import Environment, FileSystemLoader
from datetime import datetime
import subprocess
import json
import os
import requests
import sys
import re

import contextlib

@contextlib.contextmanager
def chdir(dirname):
  '''Withable chdir function that restores directory'''
  curdir = os.getcwd()
  try:
    os.chdir(dirname)
    yield
  finally: os.chdir(curdir)

class Slack:
  def __init__(self, config, token_file):
    self.disabled = True
    try:
      from slackclient import SlackClient
    except:
      print("Warning: SlackClient library not found, not using slack\n", file=sys.stderr)
      return

    try:
      self.channel = config['channel']
      self.method = config['method']
      self.username = config['username']
      self.emoji = config['emoji']
    except (TypeError, KeyError) as e:
      print("Warning: slack not setup in config (error: %s). Not using slack.\n" % e, file=sys.stderr)
      return

    try:
      with open(token_file) as stoken:
        r = stoken.readlines()
      slack_token = ''.join(r).strip()
      self.client = SlackClient(slack_token)
    except IOError:
      print("Warning: slack token file %s not found/readable. Not using slack.\n" % token_file, file=sys.stderr)
      return

    self.disabled = False

  def api_call(self, text):
    if not self.disabled:
      self.client.api_call(self.method, channel=self.channel, username=self.username, icon_emoji=self.emoji, text=text)


# Author: cwhitten
# Purpose: Initial plumbing for a standardized deployment
#          process into the ClusterOS
#
# Keys off of a master config file in APP_ROOT/config/
#   with the naming convention APP_NAME.json
# Container-specific Marathon files live in APP_ROOT/templates/ with the
#   naming convention APP_NAME-SERVICE_NAME.json
#
# See README for details and intended use.
#
# Attempts to get a version from an existing image on marathon (formatting rules apply)

# Expected format:
#   <host>:<port>/moz-content-agora-7da406eb9e8937875e0548ae1149/v0.46
def getNextVersion(config, roger_env, environment, application, branch, repo):
    imageRe = re.compile("^[^/].*/(.*)-[0-9a-f]+/v([0-9.]+)")
    data = getMarathonState(roger_env, environment)
    sha = getGitSha(repo, branch)
    currentSha = ''
    version = ''

    for app in data['apps']:
      if app['container'] != None:
        match = imageRe.match(app['container']['docker']['image'])
        if match and match.group(1) == (config['name'] + '-' + application): # Regex must match up with image naming scheme below
          currentSha = extractShaFromImage(app['container']['docker']['image'])
          if currentSha is None:
            print('''
              Current {} image has no embedded SHA, continuing..
              '''.format(application))

          version = match.group(2)
          newVersion = "{}/v{}".format(sha, Decimal(version) + Decimal(10) ** -2)
          print("Bumping version: {}".format(newVersion))
          return newVersion

    return "{}/v{}".format(sha, Decimal(0.00) + Decimal(10) ** -2)

# Expected format:
#   <host>:<port>/moz-<project>-<service>-<sha>/v0.46
def getCurrentVersion(config, environment, application):
  data = data = getMarathonState(config, environment)

  for app in data['apps']:
    if app['container'] != None:
      if application in app['container']['docker']['image']:
        return extractFullShaAndVersion(app['container']['docker']['image'])

# Expected format:
#   <host>:<port>/moz-content-kairos-7da406eb9e8937875e0548ae1149/v0.46
def extractFullShaAndVersion(image):
  return image.split('-')[3]

# Expected format:
#   <host>:<port>/moz-content-kairos-7da406eb9e8937875e0548ae1149/v0.46
def extractShaFromImage(image):
  sha = image.split('/')
  if sha != None and sha[1] != None:
    sha = sha[1].split('-')
    if sha[3] != None:
      return sha[3]
  return ''

def getMarathonState(roger_env, environment):
  url = roger_env['environments'][environment]['marathon_endpoint']+"/v2/apps"
  resp = requests.get(url)
  return resp.json()

def getGitSha(repo, branch):
  with chdir('src/' + repo):
    proc = subprocess.Popen(
        ["git rev-parse origin/{} --verify HEAD".format(branch)],
        stdout=subprocess.PIPE, shell=True)

    out = proc.communicate()
    return out[0].split('\n')[0]

def parseArgs():
  parser = argparse.ArgumentParser(description='Deploy into Roger.')
  parser.add_argument('-environment', metavar='env',
    help="Environment to deploy to. example: 'dev' or 'stage'")
  parser.add_argument('application', metavar='apps',
    help="Target to be deployed. example: 'all' or 'kairos'")
  parser.add_argument('branch', metavar='branch',
    help="Branch to be deployed. example: 'production' or 'master'")
  parser.add_argument('config_file', metavar='config_file',
    help="Configuration file to be used for the project. example: 'content.json' or 'kwe.json'")
  return parser

def getArgs(applicationRoot):
  parser = parseArgs()
  args = parser.parse_args()

  with open('{0}/config/{1}'.format(applicationRoot, args.config_file)) as config:
    config = json.load(config)

  if args.application != 'all' and args.application not in config['apps'].keys():
    sys.exit('Application specified not found.')

  return args

def loadSecretsJson(environment, jsonFileName):
  path = 'secretenvs/' + environment + '/' + jsonFileName
  try:
    with open(path) as f:
      return json.load(f)
  except IOError:
    print("Couldn't load secrets file environment %s\n" % path, file=sys.stderr)
    return {}

def mergeSecrets(jsonStr, secretsObj):
  '''Given a JSON stirng and an object of secret environment variables, replaces
  parses the JSON and merges ['env'] with the secret variables. Returns back
  a JSON string. Raises an error if there are any SECRET env variables still.'''
  outputObj = json.loads(jsonStr)
  if secretsObj:
    outputObj['env'].update(secretsObj)
    jsonStr = json.dumps(outputObj, indent=4)
  for k, v in outputObj['env'].iteritems():
    if v == 'SECRET':
      raise StandardError('env[%s] is still SECRET -- does your secretenvs file have all secret environment variables?' % k)
  return jsonStr

def renderTemplate(template, version, environment, image, app_data, config):
    output = ''
    variables = {}
    variables['version'] = version
    variables['environment'] = environment
    variables['image'] = image

    #Adding Global and environment variables for all apps
    if 'vars' in config:
      if 'global' in config['vars']:
        for global_var in config['vars']['global']:
          variables[global_var] = config['vars']['global'][global_var]

      if 'environment' in config['vars']:
        if environment in config['vars']['environment']:
          for env_var in config['vars']['environment'][environment]:
            variables[env_var] = config['vars']['environment'][environment][env_var]

    #Adding Global and environment variables for specific app.
    #If the same variable is already present in "variables" dictonary,it will get overriden
    if 'vars' in app_data:
      if 'global' in app_data['vars']:
        for global_var in app_data['vars']['global']:
          variables[global_var] = app_data['vars']['global'][global_var]

      if 'environment' in app_data['vars']:
        if environment in app_data['vars']['environment']:
          for env_var in app_data['vars']['environment'][environment]:
            variables[env_var] = app_data['vars']['environment'][environment][env_var]

    output = template.render(variables)
    return output

def main():
  applicationRoot = os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../'))
  args = getArgs(applicationRoot)
  with open('{0}/config/roger-env.json'.format(applicationRoot)) as roger_env:
    roger_env = json.load(roger_env)

  with open('{0}/config/{1}'.format(applicationRoot, args.config_file)) as config:
    config = json.load(config)

  #Setup for Slack-Client, token, and git user
  slack = Slack(config['notifications'], '.slack_token')

  os.chdir(applicationRoot)
  if not os.path.isdir('src'):
    os.mkdir('src')

  if args.application == 'all':
    apps = config['apps'].keys()
  else:
    apps = [args.application]

  os.chdir(applicationRoot)
  common_repo = ''
  if 'repo' in config.keys():
	common_repo = config['repo']

  environment = roger_env['default']
  if args.environment is None:
    if "ROGER_ENV" in os.environ:
      env_var = os.environ.get('ROGER_ENV')
      if env_var == '':
        print("Environment variable $ROGER_ENV is not set. Using the default as 'dev'")
      else:
        print("Using value {} from environment variable $ROGER_ENV".format(env_var))
        environment = env_var 
  else:
    environment = args.environment

  for app in apps:
    deployApp(config, roger_env, environment, app, args.branch, slack, args.config_file, common_repo)

def deployApp(config, roger_env, environment, app, branch, slack, config_file, common_repo):
  startTime = datetime.now()

  applicationRoot = os.path.dirname(os.path.realpath(__file__))
  environmentObj = roger_env['environments'][environment]
  data = config['apps'][app]
  repo = ''
  if common_repo != '':
    repo = data['repo'] if 'repo' in data else common_repo
  else:
    repo = data['repo'] if 'repo' in data else app

  print("rm -rf src/{}".format(repo))
  os.system("rm -rf src/{}".format(repo))
  version = ''
  image = ''

  # get/update target source(s)
  path = "src/{}".format(repo)
  if os.path.isdir(path):
    with chdir(path):
      os.system("git checkout {}".format(branch))
      os.system("git pull origin {}".format(branch))
  else:
    with chdir('src'):
      os.system("git clone git@github.com:seomoz/{}.git".format(repo))
      with chdir(repo):
        os.system("git checkout {}".format(branch))

  if 'imageBase' in data:       #If imageBase not present for the app, then docker build,tag and push is not needed to do
    version = getNextVersion(config, roger_env, environment, app, branch, repo)

    # build/tag docker images
    if version != 'current':
      with chdir(path):
        os.system("{0}/bin/docker-build {1} {2}".format(applicationRoot, config_file, data['imageBase']))

      image = "{0}/{1}-{2}-{3}".format(
        config['registry'], config['name'], app, version)
      
      os.system("docker tag -f {0} {1}".format(data['imageBase'], image))
      os.system("docker push {0}".format(image))

      version_message = "IMAGE TAGGED AND PUSHED TO REGISTERY COMPLETED, VERSION: {}".format(version)
      #slack.api_call(version_message)
      print(version_message)
    else:
      version = getCurrentVersion(config, environment, app)

  # template marathon files
  for container in data['containers']:
    containerConfig = "{0}-{1}.json".format(config['name'], container)
    template = ''
    if 'config_path' not in data:
      env = Environment(loader=FileSystemLoader("templates/"))
    else:
      applicationRoot = os.path.dirname(os.path.realpath(__file__))
      app_path = applicationRoot+"/src/{0}/{1}".format(repo, data['config_path'])
      env = Environment(loader=FileSystemLoader("{}".format(app_path)))
    
    template = env.get_template(containerConfig)

    output = renderTemplate(template, version, environment, image, data, config)
    #Adding check so that not all apps try to mergeSecrets 
    outputObj = json.loads(output)
    if 'env' in outputObj:
      if "SECRET" in outputObj['env']:
        output = mergeSecrets(output, loadSecretsJson(environment, containerConfig))

    try:
      os.system("rm -rf components/")	#Need to remove an already existing components directory,else it doesn't create seperate sub-dirs for environments
      os.mkdir("components")
      os.mkdir("components/{0}".format(environment));
    except:
      pass
    with open("components/{0}/{1}".format(environment, containerConfig), 'wb') as fh:
      fh.write(output)

  
  # push to roger
  for container in data['containers']:
    containerConfig = "{0}-{1}.json".format(config['name'], container)
    data = open("components/{0}/{1}".format(environment, containerConfig)).read()

    print("TRIGGERING MARATHON APPLICATION UPDATE FOR: {}".format(container))
    appName = json.loads(data)['id']

    if 'group' in data:
      resp = requests.put(
        "{}/v2/groups/{}".format(environmentObj['marathon_endpoint'], appName),
        data=data,
        headers = {'Content-type': 'application/json'})
      print("curl -X PUT -H 'Content-type: application/json' --data-binary @components/{} {}/v2/groups/{}".format(containerConfig, environmentObj['marathon_endpoint'], appName))
    else:
      resp = requests.put(
        "{}/v2/apps/{}".format(environmentObj['marathon_endpoint'], appName),
        data=data,
        headers = {'Content-type': 'application/json'})
      print("curl -X PUT -H 'Content-type: application/json' --data-binary @components/{} {}/v2/apps/{}".format(containerConfig, environmentObj['marathon_endpoint'], appName))
    marathon_message = "{0}: {1}".format(appName, resp)
    #slack.api_call(marathon_message)
    print(marathon_message)

  deployTime = datetime.now() - startTime
  git_username = subprocess.check_output("git config user.name", shell=True)
  deployMessage = "{0}'s deploy for {1} / {2} / {3} ({5}) completed in {4} seconds. Marathon says: {6}".format(
    git_username.rstrip(), app, environment, branch, deployTime.total_seconds(), version, marathon_message)
  slack.api_call(deployMessage)
  print(deployMessage)


if __name__ == "__main__":
  main()

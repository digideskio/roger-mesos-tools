#!/usr/bin/python

import argparse
from decimal import *
from jinja2 import Environment, FileSystemLoader
from datetime import datetime
import subprocess
import json
import os
import requests
import sys
import re

import contextlib

@contextlib.contextmanager
def chdir(dirname):
  '''Withable chdir function that restores directory'''
  curdir = os.getcwd()
  try:
    os.chdir(dirname)
    yield
  finally: os.chdir(curdir)

class Slack:
  def __init__(self, config, token_file):
    self.disabled = True
    try:
      from slackclient import SlackClient
    except:
      sys.stderr.write("Warning: SlackClient library not found, not using slack\n")
      return

    try:
      self.channel = config['channel']
      self.method = config['method']
      self.username = config['username']
      self.emoji = config['emoji']
    except (TypeError, KeyError) as e:
      sys.stderr.write("Warning: slack not setup in config (error: %s). Not using slack.\n" % e)
      return

    try:
      with open(token_file) as stoken:
        r = stoken.readlines()
      slack_token = ''.join(r).strip()
      self.client = SlackClient(slack_token)
    except IOError:
      sys.stderr.write("Warning: slack token file %s not found/readable. Not using slack.\n" % token_file)
      return

    self.disabled = False

  def api_call(self, text):
    if not self.disabled:
      self.client.api_call(self.method, channel=self.channel, username=self.username, icon_emoji=self.emoji, text=text)


# Author: cwhitten
# Purpose: Initial plumbing for a standardized deployment
#          process into the ClusterOS
#
# Keys off of a master config file in APP_ROOT/config/
#   with the naming convention APP_NAME.json
# Container-specific Marathon files live in APP_ROOT/templates/ with the
#   naming convention APP_NAME-SERVICE_NAME.json
#
# See README for details and intended use.
#
# Attempts to get a version from an existing image on marathon (formatting rules apply)

# Expected format:
#   <host>:<port>/moz-content-agora-7da406eb9e8937875e0548ae1149/v0.46
def getNextVersion(config, environment, application, branch, repo):
    imageRe = re.compile("^[^/].*/(.*)-[0-9a-f]+/v([0-9.]+)")
    data = getMarathonState(config, environment)
    sha = getGitSha(repo, branch)
    currentSha = ''
    version = ''

    for app in data['apps']:
      if app['container'] != None:
        match = imageRe.match(app['container']['docker']['image'])
        if match and match.group(1) == (config['name'] + '-' + application): # Regex must match up with image naming scheme below
          currentSha = extractShaFromImage(app['container']['docker']['image'])
          if currentSha is None:
            print '''
              Current {} image has no embedded SHA, continuing..
              '''.format(application)

          version = match.group(2)
          newVersion = "{}/v{}".format(sha, Decimal(version) + Decimal(10) ** -2)
          print "Bumping version: {}".format(newVersion)
          return newVersion

    return "{}/v{}".format(sha, Decimal(0.00) + Decimal(10) ** -2)

# Expected format:
#   <host>:<port>/moz-<project>-<service>-<sha>/v0.46
def getCurrentVersion(config, environment, application):
  data = data = getMarathonState(config, environment)

  for app in data['apps']:
    if app['container'] != None:
      if application in app['container']['docker']['image']:
        return extractFullShaAndVersion(app['container']['docker']['image'])

# Expected format:
#   <host>:<port>/moz-content-kairos-7da406eb9e8937875e0548ae1149/v0.46
def extractFullShaAndVersion(image):
  return image.split('-')[3]

# Expected format:
#   <host>:<port>/moz-content-kairos-7da406eb9e8937875e0548ae1149/v0.46
def extractShaFromImage(image):
  sha = image.split('/')
  if sha != None and sha[1] != None:
    sha = sha[1].split('-')
    if sha[3] != None:
      return sha[3]
  return ''

def getMarathonState(config, environment):
  url = config['environments'][environment]['orchestration']+"v2/apps"
  resp = requests.get(url)
  return resp.json()

def getGitSha(repo, branch):
  with chdir('src/' + repo):
    proc = subprocess.Popen(
        ["git rev-parse origin/{} --verify HEAD".format(branch)],
        stdout=subprocess.PIPE, shell=True)

    out = proc.communicate()
    return out[0].split('\n')[0]

def parseArgs():
  parser = argparse.ArgumentParser(description='Deploy into Roger.')
  parser.add_argument('environment', metavar='env',
    help="Environment to deploy to. example: 'dev' or 'stage'")
  parser.add_argument('application', metavar='apps',
    help="Target to be deployed. example: 'all' or 'kairos'")
  parser.add_argument('branch', metavar='branch',
    help="Branch to be deployed. example: 'production' or 'master'")
  parser.add_argument('config_file', metavar='config_file',
    help="Configuration file to be used for the project. example: 'content.json' or 'kwe.json'")
  return parser

def getArgs():
  parser = parseArgs()
  args = parser.parse_args()

  with open('config/{}'.format(args.config_file)) as config:
    config = json.load(config)

  if args.environment not in config['environments'].keys():
    sys.exit('Environment specified not found.')

  if args.application != 'all' and args.application not in config['apps'].keys():
    sys.exit('Application specified not found.')

  return args

def loadSecretsJson(environment, jsonFileName):
  path = 'secretenvs/' + environment + '/' + jsonFileName
  try:
    with open(path) as f:
      return json.load(f)
  except IOError:
    sys.stderr.write("Couldn't load secrets file environment %s\n" % path)
    return {}

def mergeSecrets(jsonStr, secretsObj):
  '''Given a JSON stirng and an object of secret environment variables, replaces
  parses the JSON and merges ['env'] with the secret variables. Returns back
  a JSON string. Raises an error if there are any SECRET env variables still.'''
  outputObj = json.loads(jsonStr)
  if secretsObj:
    outputObj['env'].update(secretsObj)
    jsonStr = json.dumps(outputObj, indent=4)
  for k, v in outputObj['env'].iteritems():
    if v == 'SECRET':
      raise StandardError('env[%s] is still SECRET -- does your secretenvs file have all secret environment variables?' % k)
  return jsonStr


def main():
  args = getArgs()
  with open('config/{}'.format(args.config_file)) as config:
    config = json.load(config)

  #Setup for Slack-Client, token, and git user
  slack = Slack(config['notifications'], '.slack_token')

  applicationRoot = os.path.dirname(os.path.realpath(__file__))

  if not os.path.isdir('src'):
    os.mkdir('src')

  if args.application == 'all':
    apps = config['apps'].keys()
  else:
    apps = [args.application]

  os.chdir(applicationRoot)
  for app in apps:
    deployApp(config, args.environment, app, args.branch, slack, args.config_file)

def deployApp(config, environment, app, branch, slack, config_file):
  startTime = datetime.now()

  environmentObj = config['environments'][environment]
  data = config['apps'][app]
  repo = data['repo'] if 'repo' in data else app

  print "sudo rm -rf src/{}".format(repo)
  os.system("sudo rm -rf src/{}".format(repo))

  # get/update target source(s)
  path = "src/{}".format(repo)
  if os.path.isdir(path):
    with chdir(path):
      os.system("git checkout {}".format(branch))
      os.system("git pull origin {}".format(branch))
  else:
    with chdir('src'):
      os.system("git clone git@github.com:seomoz/{}.git".format(repo))
      with chdir(repo):
        os.system("git checkout {}".format(branch))

  version = getNextVersion(config, environment, app, branch, repo)

  # build/tag docker images
  if version != 'current':
    with chdir(path):
      os.system("../../docker-build {0} {1}".format(config_file,data['imageBase']))

    image = "{0}/{1}-{2}-{3}".format(
      config['registry'], config['name'], app, version)

    os.system("docker tag -f {0} {1}".format(data['imageBase'], image))
    os.system("docker push {0}".format(image))

    version_message = "IMAGE TAGGED AND PUSHED TO REGISTERY COMPLETED, VERSION: {}".format(version)
    #slack.api_call(version_message)
    print version_message
  else:
    version = getCurrentVersion(config, environment, app)

  # template marathon files
  for container in data['containers']:
    containerConfig = "{0}-{1}.json".format(config['name'], container)
    env = Environment(loader=FileSystemLoader("templates/{}".format(environment)))
    template = env.get_template(containerConfig)

    output = template.render(version=version, environment=environment, image=image)
    output = mergeSecrets(output, loadSecretsJson(environment, containerConfig))

    try:
      os.mkdir("components")
      os.mkdir("components/{0}".format(environment));
    except:
      pass
    with open("components/{0}/{1}".format(environment,containerConfig), 'wb') as fh:
      fh.write(output)

  # push to roger
  for container in data['containers']:
    containerConfig = "{0}-{1}.json".format(config['name'], container)
    data = open("components/{0}/{1}".format(environment,containerConfig)).read()

    print "TRIGGERING MARATHON APPLICATION UPDATE FOR: {}".format(container)
    appName = containerConfig.split('.')[0]

    if version != Decimal(0.00):
      resp = requests.put(
        "{}v2/apps/{}".format(environmentObj['orchestration'], appName),
        data=data,
        headers = {'Content-type': 'application/json'})
      marathon_message = "{0}: {1}".format(appName, resp)
      #slack.api_call(marathon_message)
      print marathon_message
    else:
      resp = requests.post(
        "{}v2/apps/{}".format(environmentObj['orchestration'], appName),
        data=data,
        headers = {'Content-type': 'application/json'})
      marathon_message = "{0}: {1}".format(appName, resp.status_code)
      #slack.api_call(marathon_message)
      print marathon_message

  deployTime = datetime.now() - startTime
  git_username = subprocess.check_output("git config user.name", shell=True)
  deployMessage = "{0}'s deploy for {1} / {2} / {3} ({5}) completed in {4} seconds. Marathon says: {6}".format(
    git_username.rstrip(), app, environment, branch, deployTime.total_seconds(), version, marathon_message)
  slack.api_call(deployMessage)
  print deployMessage

if __name__ == "__main__":
  main()

#!/usr/bin/python

from __future__ import print_function
import argparse
from jinja2 import Environment, FileSystemLoader
from datetime import datetime
import requests
import json
import os
import sys
import traceback
import logging
from settings import Settings
from appconfig import AppConfig
from marathon import Marathon
from chronos import Chronos
from frameworkUtils import FrameworkUtils

import contextlib

@contextlib.contextmanager
def chdir(dirname):
  '''Withable chdir function that restores directory'''
  curdir = os.getcwd()
  try:
    os.chdir(dirname)
    yield
  finally: os.chdir(curdir)

def parse_args():
  parser = argparse.ArgumentParser(description='To deploy an app to framework. Marathon by default')
  parser.add_argument('app_name', metavar='app_name',
    help="Application to be built. Example: 'agora' or 'grafana'")
  parser.add_argument('-e', '--env', metavar='env',
    help="Environment to deploy to. Example: 'dev' or 'prod'")
  parser.add_argument('directory', metavar='directory',
    help="Working directory where the pulled in repo exists. Template file is under this repo dir. Example: '/home/vagrant/work_dir'")
  parser.add_argument('image_name', metavar='image_name',
    help="Image name that includes version to be used in docker push. Example: 'roger-collectd-v0.20' or 'elasticsearch-v0.07'")
  parser.add_argument('config_file', metavar='config_file',
    help="Configuration file to be used for the project. Example: 'content.json' or 'kwe.json'")
  parser.add_argument('--skip-push', '-s', help="Don't push. Only generate components. Defaults to false.", action="store_true")
  return parser

def loadSecretsJson(secrets_dir, jsonFileName):
  exists = os.path.exists(secrets_dir)
  if exists == False:
   os.makedirs(secrets_dir)
  path = "{}/{}".format(secrets_dir, jsonFileName)
  try:
    with open(path) as f:
      return json.load(f)
  except IOError:
    print("Couldn't load secrets file environment %s\n" % path, file=sys.stderr)
    return {}

def mergeSecrets(jsonStr, secretsObj):
  '''Given a JSON stirng and an object of secret environment variables, replaces
  parses the JSON and merges ['env'] with the secret variables. Returns back
  a JSON string. Raises an error if there are any SECRET env variables still.'''
  outputObj = json.loads(jsonStr)
  if secretsObj:
    outputObj['env'].update(secretsObj)
    jsonStr = json.dumps(outputObj, indent=4)
  for k, v in outputObj['env'].iteritems():
    if v == 'SECRET':
      raise StandardError('env[%s] is still SECRET -- does your secretenvs file have all secret environment variables?' % k)
  return jsonStr

def renderTemplate(template, environment, image, app_data, config):
    output = ''
    variables = {}
    variables['environment'] = environment
    variables['image'] = image

    #Adding Global and environment variables for all apps
    if 'vars' in config:
      if 'global' in config['vars']:
        for global_var in config['vars']['global']:
          variables[global_var] = config['vars']['global'][global_var]

      if 'environment' in config['vars']:
        if environment in config['vars']['environment']:
          for env_var in config['vars']['environment'][environment]:
            variables[env_var] = config['vars']['environment'][environment][env_var]

    #Adding Global and environment variables for specific app.
    #If the same variable is already present in "variables" dictonary,it will get overriden
    if 'vars' in app_data:
      if 'global' in app_data['vars']:
        for global_var in app_data['vars']['global']:
          variables[global_var] = app_data['vars']['global'][global_var]

      if 'environment' in app_data['vars']:
        if environment in app_data['vars']['environment']:
          for env_var in app_data['vars']['environment'][environment]:
            variables[env_var] = app_data['vars']['environment'][environment][env_var]

    #Adding Global and environment variables for containers.
    for app_container_values in config["apps"].values():
        if "containers" in app_container_values:
            for value in app_container_values["containers"]:
                #  app_container_values["containers"] is a list of values within containers. Eg [ app1,app2 ] , [ test: {vars: {gloabl{} , environment {}}}]
                if type(value) == dict:
                    for each_key in value.keys():
                        if "vars" in value[each_key]:

                            if "global" in value[each_key]["vars"]:
                                for global_var in value[each_key]["vars"]["global"]:
                                    variables[global_var] = value[each_key]["vars"]["global"][global_var]

                            if "environment" in value[each_key]["vars"]:
                                if environment in value[each_key]["vars"]["environment"]:
                                    for environment_var in value[each_key]["vars"]["environment"][environment]:
                                        variables[environment_var] = value[each_key]["vars"]["environment"][environment][environment_var]

    output = template.render(variables)
    return output

def main(object_list, args):
  settingObj = object_list[0]
  appObj = object_list[1]
  frameworkUtils = object_list[2]
  config_dir = settingObj.getConfigDir()

  cur_file_path = os.path.dirname(os.path.realpath(__file__))
  config = appObj.getConfig(config_dir, args.config_file)
  roger_env = appObj.getRogerEnv(config_dir)

  if 'registry' not in roger_env.keys():
    sys.exit('Registry not found in roger-env.json file.')

  if args.app_name not in config['apps'].keys():
    sys.exit('Application specified not found.')

  environment = roger_env.get('default', '')
  if args.env is None:
    if "ROGER_ENV" in os.environ:
      env_var = os.environ.get('ROGER_ENV')
      if env_var.strip() == '':
        print("Environment variable $ROGER_ENV is not set. Using the default set from roger-env.json file")
      else:
        print("Using value {} from environment variable $ROGER_ENV".format(env_var))
        environment = env_var
  else:
    environment = args.env

  if environment not in roger_env['environments']:
    sys.exit('Environment not found in roger-env.json file.')

  environmentObj = roger_env['environments'][environment]
  common_repo = config.get('repo', '')
  data = appObj.getAppData(config_dir, args.config_file, args.app_name)
  frameworkObj = frameworkUtils.getFramework(data)
  framework = frameworkObj.getName()

  repo = ''
  if common_repo != '':
    repo = data.get('repo', common_repo)
  else:
    repo = data.get('repo', args.app_name)

  comp_dir = settingObj.getComponentsDir()
  templ_dir = settingObj.getTemplatesDir()
  secrets_dir = settingObj.getSecretsDir()

  # template marathon files
  for container in data['containers']:

    if type(container) == dict:
       container_name = str(container.keys()[0])
       containerConfig = "{0}-{1}.json".format(config['name'], container_name)
    else:
       containerConfig = "{0}-{1}.json".format(config['name'], container)

    template = ''
    os.chdir(cur_file_path)	#Required for when work_dir,component_dir,template_dir or secret_env_dir is something like '.' or './temp"
    app_path = ''
    if 'template_path' not in data:
      app_path = templ_dir
    else:
      cur_dir = ''
      if "PWD" in os.environ:
        cur_dir = os.environ.get('PWD')
      abs_path = os.path.abspath(args.directory)
      if abs_path == args.directory:
        app_path = "{0}/{1}/{2}".format(args.directory, repo, data['template_path'])
      else:
        app_path = "{0}/{1}/{2}/{3}".format(cur_dir, args.directory, repo, data['template_path'])

    if not app_path.endswith('/'):
        app_path = app_path + '/'

    env = Environment(loader=FileSystemLoader("{}".format(app_path)))
    template = env.get_template(containerConfig)
    image_path = "{0}/{1}".format(roger_env['registry'], args.image_name)
    print("Rendering content from template [{}{}] for environment [{}]".format(app_path, containerConfig, environment))
    output = renderTemplate(template, environment, image_path, data, config)
    #Adding check so that not all apps try to mergeSecrets
    outputObj = json.loads(output)
    if 'env' in outputObj:
      if "SECRET" in outputObj['env'].values():
        output = mergeSecrets(output, loadSecretsJson(secrets_dir, containerConfig))

    try:
      comp_exists = os.path.exists("{0}".format(comp_dir))
      if comp_exists == False:
        os.makedirs("{0}".format(comp_dir))
      comp_env_exists = os.path.exists("{0}/{1}".format(comp_dir, environment))
      if comp_env_exists == False:
        os.makedirs("{0}/{1}".format(comp_dir, environment))
    except Exception as e:
      logging.error(traceback.format_exc())
    with open("{0}/{1}/{2}".format(comp_dir, environment, containerConfig), 'wb') as fh:
      fh.write(output)

  if args.skip_push:
      print("Skipping push to {} framework. The rendered config file(s) are under {}/{}".format(framework, comp_dir, environment))
  else:
      # push to roger framework
      for container in data['containers']:

        if type(container) == dict:
           container_name = str(container.keys()[0])
           containerConfig = "{0}-{1}.json".format(config['name'], container_name)
        else:
           containerConfig = "{0}-{1}.json".format(config['name'], container)

        containerConfig = "{0}-{1}.json".format(config['name'], container)
        config_file_path = "{0}/{1}/{2}".format(comp_dir, environment, containerConfig)
        frameworkObj.put(config_file_path, environmentObj, container)

if __name__ == "__main__":
  settingObj = Settings()
  appObj = AppConfig()
  frameworkUtils = FrameworkUtils()
  object_list = []
  object_list.append(settingObj)
  object_list.append(appObj)
  object_list.append(frameworkUtils)
  parser = parse_args()
  args = parser.parse_args()
  main(object_list, args)
